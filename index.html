<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cricklade Resilience</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }

    .fa-icon {
      font-size: 24px;
      color: blue;
      text-shadow: 0 0 2px white;
    }

    .locate-button {
      background-color: white;
      border: none;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 18px;
      border-radius: 4px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.65);
    }

    .locate-button:hover { background-color: #f0f0f0; }
    .locate-button {
  position: absolute;
  bottom: 20px;
  right: 10px;
  z-index: 1000;
  background-color: white;
  border: none;
  padding: 6px 10px;
  cursor: pointer;
  font-size: 18px;
  border-radius: 4px;
  box-shadow: 0 1px 5px rgba(0,0,0,0.65);
}


    .popup-image {
      max-width: 100px;
      max-height: 75px;
      margin-top: 5px;
      border-radius: 4px;
      display: block;
      object-fit: contain;
    }

    @media (max-width: 768px) {
      .popup-image {
        max-width: 180px;
        max-height: 135px;
      }
    }

    .point-label-red, .point-label-green, .point-label-orange,
    .point-label-blue, .point-label-brown {
      font-weight: bold;
      background: white;
      border-radius: 4px;
      padding: 2px 4px;
      border: 1px solid #ccc;
    }

    .point-label-red { color: red; }
    .point-label-green { color: green; }
    .point-label-orange { color: orange; }
    .point-label-blue { color: blue; }
    .point-label-brown { color: brown; }

    .polygon-label {
      font-weight: bold;
      color: black;
      background: white;
      padding: 2px 6px;
      border: 1px solid #999;
      border-radius: 3px;
      font-size: 12px;
      pointer-events: none; /* so labels donâ€™t capture mouse */
    }

  .info-box {
  position: absolute;
  bottom: 60px;
  left: 10px;
  width: 300px;
  background: white;
  border: 1px solid #999;
  border-radius: 6px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  padding: 15px;
  z-index: 1100;
  font-family: sans-serif;
  font-size: 16px
}

.info-box h3 {
  margin-top: 0;
}

.info-box button {
  margin-top: 10px;
  background: #eee;
  border: none;
  padding: 10px 18px;
  font-size: 16px
  cursor: pointer;
  border-radius: 4px;
}
.info-box button:hover {
  background: #ddd;
}


  </style>
</head>
<body>
<div id="map"></div>
<button onclick="locateUser()" class="locate-button">
  <i class="fa-solid fa-location-crosshairs"></i>
</button>

<div id="infoBox" class="info-box" style="display: none;">
  <h3>Cricklade Resilience Map</h3>
  <img src="Images/CrickladeLogo.png" alt="Cricklade" style="width:100px;height:100px;">
  <p>This map is designed to help Cricklade Councillors and Resilience Wardens to prepare for, mitigate and monitor known risks within the town and local area.  Use the Layers menu to browse the available datasets, use the Locate button to view were you are in relation to specific features, and use the links below to record any actions and notes.  .</p>
  <p>
  <p>Documents accessible for Cricklade Councillors and Resilience Wardens only:</p>
    <a href="https://www.dropbox.com/scl/fi/phwnkt0tiwfbdguzj1kv1/Cricklade-Town-Council-Resilience-Plan_CouncilUpdate.docx?rlkey=oskyd4yajlnibqi3q8lp1bcz9&st=l56m902a&dl=0" target="_blank">ðŸ“„ Resilience Plan  (PDF)</a><br>
    <a href="https://www.dropbox.com/scl/fi/drdvws0x2s315gxj24fe2/Area-Checklist.xlsx?rlkey=2906kyl08vcdb4z8t4grewsqm&st=kjxrzig9&dl=0" target="_blank">âœ… Area Checklist</a>
    <a href="https://www.dropbox.com/scl/fi/2lvxyoccpvv06sbc5kza2/Emergency-kit-list-may-2022-v3.xlsx?rlkey=21j35rdh277gaunas3lm3mn5z&st=46bg5yxw&dl=0" target="_blank">ï‡ƒ Emergency Kit List</a>
  </p>
  <button onclick="closeInfoBox()">Close</button>
</div>

</body>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const map = L.map('map').setView([51.6409, -1.8577], 14);

const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; OpenStreetMap & CartoDB', subdomains: 'abcd', maxZoom: 19
}).addTo(map);

const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: 'Â© OpenStreetMap contributors'
});

const esriAerial = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles Â© Esri'
});

const baseMaps = {
  "Greyscale (Carto)": cartoLight,
  "OpenStreetMap": osm,
  "Aerial (Esri)": esriAerial
};

const floodZone3WMS = L.tileLayer.wms("https://environment.data.gov.uk/spatialdata/flood-map-for-planning-rivers-and-sea-flood-zone-3/wms", {
  layers: "Flood_Map_for_Planning_Rivers_and_Sea_Flood_Zone_3",
  format: "image/png", transparent: true, attribution: "Â© Environment Agency"
});

const floodZone2WMS = L.tileLayer.wms("https://environment.data.gov.uk/spatialdata/flood-map-for-planning-rivers-and-sea-flood-zone-2/wms", {
  layers: "Flood_Map_for_Planning_Rivers_and_Sea_Flood_Zone_2",
  format: "image/png", transparent: true, attribution: "Â© Environment Agency"
});

const faShopIcon = L.divIcon({ html: '<i class="fa-solid fa-shop" style="color: orange;"></i>', className: 'fa-icon', iconSize: [24, 24] });
const WILD = L.divIcon({ html: '<i class="fa-solid fa-diamond" style="color: blue;"></i>', className: 'fa-icon', iconSize: [24, 24] });
const shelter = L.divIcon({ html: '<i class="fa-solid fa-bed" style="color: green;"></i>', className: 'fa-icon', iconSize: [24, 24] });
const storage = L.divIcon({ html: '<i class="fa-solid fa-boxes-packing" style="color: brown;"></i>', className: 'fa-icon', iconSize: [24, 24] });
const medical = L.divIcon({ html: '<i class="fa-solid fa-house-medical" style="color: red;"></i>', className: 'fa-icon', iconSize: [24, 24] });
const guage = L.divIcon({ html: '<i class="fa-solid fa-gauge" style="color: blue;"></i>', className: 'fa-icon', iconSize: [24, 24] });
const histflood = L.divIcon({ html: '<i class="fa-solid fa-star" style="color: blue;"></i>', className: 'fa-icon', iconSize: [24, 24] });

const overlayBuffer = new Map();
const overlays = {};
const loadPromises = [];
const polygonLabels = new Map();

function createOnEachFeature(name, icon, label) {
  return function(feature, layerInstance) {
    const props = feature.properties || {};
    const geometryType = feature.geometry.type;
    feature.properties.layerName = name;

    if (geometryType === "Point") {
      const nameProp = props.name || "No Name";
      const desc = props.description || "";
      const imgUrl = props.imageURL || "";
      const siteURL = props.siteURL || "";

      let popupContent = `<strong>${nameProp}</strong><br>${desc}`;
      if (imgUrl) popupContent += `<br><img src="${imgUrl}" class="popup-image">`;
      if (siteURL) popupContent += `<br><a href="${siteURL}" target="_blank">Visit Website</a>`;

      layerInstance.bindPopup(popupContent);

      if (label && icon) {
        const labelColor = icon.options.html.match(/color:\s*(\w+)/i)?.[1] || "black";
        layerInstance.bindTooltip(nameProp, {
          permanent: true,
          direction: "top",
          offset: [0, -20],
          className: `point-label-${labelColor}`
        });
        layerInstance._tooltipRef = layerInstance.getTooltip();
      }
    }

    if ((geometryType === "Polygon" || geometryType === "MultiPolygon") && label) {
  const labelText = name === "Admin: Warden Zones" ? (props.id || "No ID") : (props.name || "No Name");

  if (name === "Admin: Warden Zones") {
    const center = layerInstance.getBounds().getCenter();
    const tooltip = L.tooltip({
      permanent: true,
      direction: 'center',
      className: 'polygon-label',
      offset: [0, 0]
    }).setContent(labelText).setLatLng(center);

    if (!polygonLabels.has(name)) polygonLabels.set(name, []);
    polygonLabels.get(name).push(tooltip);
    layerInstance._tooltipRef = tooltip;

  } else if (name === "Feature: Evacuation Sites") {
    const center = layerInstance.getBounds().getCenter();
    const tooltip = L.tooltip({
      permanent: true,
      direction: 'center',
      className: 'polygon-label',
      offset: [0, 0]
    }).setContent(labelText).setLatLng(center);

    if (!polygonLabels.has(name)) polygonLabels.set(name, []);
    polygonLabels.get(name).push(tooltip);
    layerInstance._tooltipRef = tooltip;
  }
}


    if (geometryType.includes("Polygon")) {
  let style = { color: "#666", weight: 2, fillOpacity: 0.2 };

  if (name === "Admin: Warden Zones") {
    style = { color: "#444", weight: 2, fillOpacity: 0.1 };
  } else if (name === "Admin: Parish Boundary") {
    style = { color: "black", weight: 3, fillOpacity: 0 };
  } else if (name === "Feature: Evacuation Sites") {
    style = { color: "red", weight: 2, fillOpacity: 0.1 };  // âœ… red fill/outline
  }

  layerInstance.setStyle(style);
}

  };
}

const layersToLoad = [
  { name: "Flood: WILD Watercourse Issues", file: "Data/Flood_WILD_Watercourse_Issues.geojson", icon: WILD, label: false },
  { name: "Feature: Medical", file: "Data/Features_Medical.geojson", icon: medical, label: true },
  { name: "Feature: Shelter", file: "Data/Features_Shelter.geojson", icon: shelter, label: true },
  { name: "Feature: Storage", file: "Data/Features_Storage.geojson", icon: storage, label: true },
  { name: "Feature: Supplies", file: "Data/Features_Supplies.geojson", icon: faShopIcon, label: true },
  { name: "Flood: Water Guages", file: "Data/Water_WaterGuages.geojson", icon: guage, label: true },
  { name: "Flood: Areas of Concern", file: "Data/Flood_HistAreas.geojson", icon: histflood, label: true },
  { name: "Admin: Warden Zones", file: "Data/CrickladeWardenZones.geojson", icon: null, label: true },
  { name: "Feature: Evacuation Sites", file: "Data/Features_EvacSites.geojson", icon: null, label: true },
  { name: "Admin: Parish Boundary", file: "Data/Admin_ParishBoundary.geojson", icon: null, label: false }
];

layersToLoad.forEach(({ name, file, icon, label }) => {
  const layer = L.geoJSON(null, {
    pointToLayer: (f, latlng) => icon ? L.marker(latlng, { icon }) : L.marker(latlng),
    onEachFeature: createOnEachFeature(name, icon, label)
  });

  const p = fetch(file)
    .then(res => res.json())
    .then(data => {
      data.features.forEach(f => f.properties.layerName = name);
      layer.addData(data);
      if (name === "Admin: Warden Zones" && polygonLabels.has(name)) {
        polygonLabels.get(name).forEach(t => map.addLayer(t));
      }
      overlayBuffer.set(name, layer);
    }).catch(err => console.error(`Error loading ${file}:`, err));

  loadPromises.push(p);
});

Promise.all(loadPromises).then(() => {
  overlays["Flood: EA Flood Zone 3 (WMS)"] = floodZone3WMS;
  overlays["Flood: EA Flood Zone 2 (WMS)"] = floodZone2WMS;

  const orderedNames = [
    "Feature: Medical", "Feature: Shelter", "Feature: Storage", "Feature: Supplies",
    "Feature: Evacuation Sites", "Flood: Water Guages", "Flood: Areas of Concern",
    "Flood: WILD Watercourse Issues", "Admin: Warden Zones", "Admin: Parish Boundary"
  ];

  orderedNames.forEach(name => {
    if (overlayBuffer.has(name)) overlays[name] = overlayBuffer.get(name);
  });

  // Add Warden Zones & Parish Boundary layers + labels by default on map load
  if (overlayBuffer.has("Admin: Warden Zones")) {
    const wardenZonesLayer = overlayBuffer.get("Admin: Warden Zones");
    wardenZonesLayer.addTo(map);
    wardenZonesLayer.eachLayer(l => {
      l.setStyle({ color: "#444", weight: 2, fillOpacity: 0.1 });
      const tooltip = l._tooltipRef;
      if (tooltip) map.addLayer(tooltip);
    });
  }

  if (overlayBuffer.has("Admin: Parish Boundary")) {
    const parishLayer = overlayBuffer.get("Admin: Parish Boundary");
    parishLayer.addTo(map);
    parishLayer.eachLayer(l => {
      l.setStyle({ color: "black", weight: 3, fillOpacity: 0 });
    });
  }

  const labelVisibilityZoom = 15;

  function updateMapDisplay() {
    const zoom = map.getZoom();

    overlayBuffer.forEach(layer => {
      layer.eachLayer(featureLayer => {
        if (featureLayer._tooltipRef) {
          if (zoom >= labelVisibilityZoom) {
            featureLayer.openTooltip();
          } else {
            featureLayer.closeTooltip();
          }
        }

        if (featureLayer.setStyle && featureLayer.feature?.geometry?.type?.includes("Polygon")) {
          const lname = featureLayer.feature.properties?.layerName;
          let weight = 2;
          if (lname === "Admin: Parish Boundary") weight = zoom >= 16 ? 5 : 4;
          else if (lname === "Admin: Warden Zones") weight = zoom >= 16 ? 3 : 2;
          featureLayer.setStyle({ weight });
        }
      });
    });
  }

  map.on("zoomend", updateMapDisplay);
  updateMapDisplay();

  L.control.layers(baseMaps, overlays, { collapsed: window.innerWidth <= 768 }).addTo(map);
});

map.on('overlayadd', e => {
  const layerName = e.name;

  const layerGroup = overlayBuffer.get(layerName);
  if (layerGroup) {
    layerGroup.eachLayer(l => {
      // Restore styles on add
      if (layerName === "Admin: Warden Zones") {
        l.setStyle({ color: "#444", weight: 2, fillOpacity: 0.1 });
      }
      if (layerName === "Admin: Parish Boundary") {
        l.setStyle({ color: "black", weight: 3, fillOpacity: 0 });
      }

      const tooltip = l._tooltipRef;
      if (tooltip) map.addLayer(tooltip);
    });
  }
});

map.on('overlayremove', e => {
  const layerName = e.name;

  const layerGroup = overlayBuffer.get(layerName);
  if (layerGroup) {
    layerGroup.eachLayer(l => {
      // Optionally reset style or leave as is
      const tooltip = l._tooltipRef;
      if (tooltip) map.removeLayer(tooltip);
    });
  }
});

////////////////////////////////////////
// Locate Button
////////////////////////////////////////
let watchId = null;
let userMarker = null;
let accuracyCircle = null;
let headingArrow = null;

function locateUser() {
  if (watchId !== null) {
    // Stop tracking
    navigator.geolocation.clearWatch(watchId);
    watchId = null;

    if (userMarker) map.removeLayer(userMarker);
    if (accuracyCircle) map.removeLayer(accuracyCircle);
    if (headingArrow) map.removeLayer(headingArrow);

    userMarker = accuracyCircle = headingArrow = null;
    return;
  }

  if (!navigator.geolocation) {
    alert("Geolocation is not supported by your browser.");
    return;
  }

  const locationIcon = L.divIcon({
    html: '<i class="fa-solid fa-location-crosshairs" style="color: purple;"></i>',
    className: 'fa-icon',
    iconSize: [24, 24]
  });

  watchId = navigator.geolocation.watchPosition(
    pos => {
      const lat = pos.coords.latitude;
      const lng = pos.coords.longitude;
      const accuracy = pos.coords.accuracy;
      const heading = pos.coords.heading; // may be null

      const latlng = [lat, lng];

      // Update or create marker
      if (!userMarker) {
        userMarker = L.marker(latlng, { icon: locationIcon }).addTo(map).bindPopup("You are here");
      } else {
        userMarker.setLatLng(latlng);
      }

      // Update or create accuracy circle
      if (!accuracyCircle) {
        accuracyCircle = L.circle(latlng, {
          radius: accuracy,
          color: 'blue',
          fillColor: '#1E90FF',
          fillOpacity: 0.2,
          weight: 1
        }).addTo(map);
      } else {
        accuracyCircle.setLatLng(latlng).setRadius(accuracy);
      }

      // Update or create heading arrow
      if (heading !== null && !isNaN(heading)) {
        const arrowLength = 30; // meters
        const angleRad = (heading - 90) * (Math.PI / 180); // Leaflet's 0Â° is East

        const destLat = lat + (arrowLength / 111320) * Math.cos(angleRad);
        const destLng = lng + (arrowLength / (40075000 * Math.cos(lat * Math.PI / 180) / 360)) * Math.sin(angleRad);

        const arrowCoords = [[lat, lng], [destLat, destLng]];

        if (!headingArrow) {
          headingArrow = L.polyline(arrowCoords, {
            color: 'purple',
            weight: 3,
            opacity: 0.8,
            dashArray: '5, 5'
          }).addTo(map);
        } else {
          headingArrow.setLatLngs(arrowCoords);
        }
      } else if (headingArrow) {
        // Remove arrow if no heading
        map.removeLayer(headingArrow);
        headingArrow = null;
      }

      // Zoom to user's position on first update
      if (!map.getBounds().contains(latlng)) {
        map.setView(latlng, 15);
      }
    },
    err => {
      alert("Unable to retrieve your location.");
      console.error(err);
    },
    {
      enableHighAccuracy: true,
      maximumAge: 1000,
      timeout: 10000
    }
  );
}

////////////////////////////////////////
// Info Button
////////////////////////////////////////
L.Control.InfoButton = L.Control.extend({
  onAdd: function(map) {
    const container = L.DomUtil.create('button', 'leaflet-bar leaflet-control leaflet-control-custom info-button');
    container.innerHTML = '<i class="fa-solid fa-circle-info"></i>';
    container.title = 'Information';

    L.DomEvent.disableClickPropagation(container);

    container.onclick = function() {
      document.getElementById('infoBox').style.display = 'block';
    };

    return container;
  },
  onRemove: function(map) {}
});

function closeInfoBox() {
  document.getElementById('infoBox').style.display = 'none';
};

new L.Control.InfoButton({ position: 'bottomleft' }).addTo(map);




  
</script>
</body>
</html>
