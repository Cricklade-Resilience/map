<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Leaflet Layer Control with Async GeoJSON</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    .polygon-label {
      background-color: rgba(255, 255, 255, 0.7);
      padding: 2px 4px;
      border-radius: 4px;
      font-weight: bold;
      font-size: 12px;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>

<div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
  const map = L.map('map').setView([51.6409, -1.8577], 14);

  // Base layers
  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: 'Â© OpenStreetMap contributors'
  });

  const esriAerial = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles Â© Esri'
  });

  const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; OpenStreetMap & CartoDB',
    subdomains: 'abcd',
    maxZoom: 19
  }).addTo(map);

  const baseMaps = {
    "Greyscale (Carto)": cartoLight,
    "OpenStreetMap": osm,
    "Aerial (Esri)": esriAerial
    
  };

  const overlays = {};
  const loadPromises = [];

  const layersToLoad = [
  { name: "Flood Zone 2", file: "Data/points.geojson", label: false },
  { name: "Flood Zone 3", file: "Data/points.geojson", label: false },
  { name: "SUDS Areas", file: "Data/polygons.geojson", label: true }
];


  layersToLoad.forEach(({ name, file, label }, index) => {
  const layer = L.geoJSON(null, {
    onEachFeature: function (feature, layerInstance) {
      const labelText = feature.properties?.id || feature.properties?.name || name;

      if (label) {
        // Permanent label in the center for polygons
        layerInstance.bindTooltip(labelText, {
          permanent: true,
          direction: "center",
          className: "polygon-label"
        });
      } else {
        // Popup for points
        layerInstance.bindPopup(labelText);
      }
    }
  });

  const p = fetch(file)
    .then(res => res.json())
    .then(data => {
      layer.addData(data);
      if (index === 0) {
        layer.addTo(map);
      }
      overlays[name] = layer;
    })
    .catch(error => console.error(`Error loading ${file}:`, error));

  loadPromises.push(p);
});


 Promise.all(loadPromises).then(() => {
  L.control.layers(baseMaps, overlays, {
    collapsed: window.innerWidth <= 768 // collapsed on mobile
  }).addTo(map);
});

// Create a custom "Locate Me" button
const locateControl = L.control({ position: 'topleft' });

locateControl.onAdd = function (map) {
  const btn = L.DomUtil.create('button', 'locate-button');
  btn.innerHTML = 'ðŸ“';
  btn.title = 'Show My Location';

  L.DomEvent.on(btn, 'click', function () {
    map.locate({ setView: true, maxZoom: 16 });
  });

  return btn;
};

locateControl.addTo(map);

// Add a marker when location is found
map.on('locationfound', function (e) {
  const radius = e.accuracy / 2;

  L.marker(e.latlng).addTo(map)
    .bindPopup(`You are within ${Math.round(radius)} meters.`)
    .openPopup();

  L.circle(e.latlng, radius).addTo(map);
});

// Handle location errors
map.on('locationerror', function (e) {
  alert('Location access denied or unavailable.');
});


</script>
</body>
</html>
