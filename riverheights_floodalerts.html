<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Cricklade River Gauges & Flood Alerts</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/esri-leaflet@3.0.19/dist/esri-leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    body { margin: 0; display: grid; grid-template-columns: 350px 1fr; height: 100vh; transition: grid-template-columns 0.3s; }
    body.sidebar-collapsed { grid-template-columns: 0px 1fr; }
    #leftPanel { background:#f5f5f5; padding: 10px; overflow-y: auto; display:flex; flex-direction:column; transition: opacity 0.3s; }
    body.sidebar-collapsed #leftPanel { opacity: 0; pointer-events: none; padding: 0; }
    #map { width: 100%; height: 100%; position: relative; }
    #collapseBtn { position: absolute; top: 10px; left: 10px; z-index: 1000; background: white; border: 2px solid #ccc; border-radius: 4px; padding: 8px 12px; cursor: pointer; font-weight: 600; box-shadow: 0 1px 4px rgba(0,0,0,0.2); }
    #collapseBtn:hover { background: #f0f0f0; }
    h2 { margin-top:0; font-size:16px; display: flex; justify-content: space-between; align-items: center; }
    .card { background: #fff; padding: 10px; border-radius: 6px; box-shadow: 0 1px 4px rgba(0,0,0,0.06); margin-bottom: 12px; }
    #totals { display:flex; gap:8px; margin-top:8px; }
    .total { flex:1; text-align:center; padding:8px; border-radius:6px; background:#f7f7f7; }
    .gauge { font-size:18px; font-weight:700; }
    canvas { width:100% !important; height:280px !important; }
    .small { font-size:12px; color:#666; }
    .last-updated { font-size:11px; color:#999; margin-top:6px; font-style: italic; }
    .error-msg { color:#d73027; font-size:12px; padding:8px; background:#ffe6e6; border-radius:4px; margin-top:8px; }
    .loading { color:#666; font-style:italic; }
    #gaugeList h3 { text-align:center; margin-top:0; margin-bottom:10px; font-size:16px; }
    .gauge-item { border-bottom:1px solid #ddd; padding:8px 0; }
    .gauge-item:last-child { border-bottom:none; }
    .gauge-dot { display:inline-block; width:14px; height:14px; border-radius:50%; border:1px solid #333; vertical-align:middle; margin-right:6px; }
    .sparkline { margin-top:4px; width:100%; height:6px; background:#eee; border-radius:3px; overflow:hidden; }
    .sparkline-bar { height:100%; border-radius:3px; }
    #gaugeContainer { flex:1; overflow-y:auto; }
    .overlay-popup { max-width: 250px; font-family: sans-serif; }
    #floodLegend h3 { text-align:center; margin-top:0; margin-bottom:10px; font-size:16px; }
    .legend-item { padding:6px 0; display:flex; align-items:center; gap:8px; }
    .legend-color { width:16px; height:16px; border-radius:3px; border:1px solid #333; }
    .flood-count { font-weight:700; font-size:20px; text-align:center; margin-bottom:8px; color:#d73027; }
    .toggle-btn { width:100%; padding:8px; margin-top:10px; background:#4a90e2; color:white; border:none; border-radius:6px; cursor:pointer; font-weight:600; transition:background 0.2s; }
    .toggle-btn:hover { background:#357abd; }
    .toggle-btn.off { background:#ccc; color:#666; }
    .toggle-btn.off:hover { background:#bbb; }
    .refresh-btn { background: none; border: none; cursor: pointer; color: #4a90e2; font-size: 18px; padding: 0 4px; }
    .refresh-btn:hover { color: #357abd; }
    .refresh-btn.spinning { animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @media (max-width: 768px) {
      body { grid-template-columns: 100% 0; }
      body.sidebar-collapsed { grid-template-columns: 0 100%; } 
    }
  </style>
</head>
<body>

<div id="leftPanel">
  <div class="card">
    <h2>
      Rainfall at Shorncote Gauge
      <button class="refresh-btn" onclick="refreshRainfall()" title="Refresh rainfall data">↻</button>
    </h2>
    <div id="totals">
      <div class="total"><div class="small">Last 1 hour</div><div id="t1" class="gauge">0 mm</div></div>
      <div class="total"><div class="small">Last 6 hours</div><div id="t6" class="gauge">0 mm</div></div>
      <div class="total"><div class="small">Last 24 hours</div><div id="t24" class="gauge">0 mm</div></div>
    </div>
    <canvas id="barChart"></canvas>
    <div class="small" id="chart-note">Most recent readings returned from API.</div>
    <div class="last-updated" id="rainfallUpdated">Loading...</div>
    <div class="error-msg" id="rainfallError" style="display:none;"></div>
  </div>

  <div class="card" id="gaugeList">
    <h3>
      River Gauge Status
      <button class="refresh-btn" onclick="refreshGauges()" title="Refresh river gauges">↻</button>
    </h3>
    <div id="gaugeContainer" class="loading">Loading gauges...</div>
    <div class="last-updated" id="gaugesUpdated"></div>
    <div class="error-msg" id="gaugesError" style="display:none;"></div>
  </div>

  <div class="card" id="floodLegend">
    <h3>
      Wiltshire Flood Alerts
      <button class="refresh-btn" onclick="refreshFloods()" title="Refresh flood alerts">↻</button>
    </h3>
    <div class="flood-count" id="floodCount">Loading...</div>
    <div class="legend-item">
      <span class="legend-color" style="background:#d73027;"></span>
      <span>Severe / Warning</span>
    </div>
    <div class="legend-item">
      <span class="legend-color" style="background:#fc8d59;"></span>
      <span>Alert / Advisory</span>
    </div>
    <div class="legend-item">
      <span class="legend-color" style="background:#fee08b;"></span>
      <span>Other</span>
    </div>
    <button class="toggle-btn" id="toggleFloodBtn" onclick="toggleFloodLayer()">Hide Flood Alerts</button>
    <div class="last-updated" id="floodsUpdated"></div>
    <div class="error-msg" id="floodsError" style="display:none;"></div>
  </div>
</div>

<div id="map">
  <button id="collapseBtn" onclick="toggleSidebar()">☰</button>
</div>

<script>
var map = L.map("map", {zoomControl:false}).setView([51.65, -1.90], 12);

L.control.zoom({
    position: 'topright'
}).addTo(map);

L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; CARTO',
  subdomains: 'abcd',
  maxZoom: 15
}).addTo(map);

/* ---- Sidebar Toggle ---- */
function toggleSidebar() {
  document.body.classList.toggle('sidebar-collapsed');
  setTimeout(() => map.invalidateSize(), 300);
}

/* ---- Station Data ---- */
var stationData = {
  "ENG0144TH": {TopNormal:1.6, PossibleFlood:2.3, Max:1.59},
  "ENG0290TH": {TopNormal:0.6, PossibleFlood:0.69, Max:0.75},
  "ENG0190TH": {TopNormal:1.08, PossibleFlood:1.38, Max:1.03},
  "ENG0490TH": {TopNormal:1.45, PossibleFlood:2.5, Max:1.2},
  "ENG0390TH": {TopNormal:1.9, PossibleFlood:null, Max:2.68},
  "ENG0184TH": {TopNormal:1.89, PossibleFlood:2.23, Max:2.34}
};

var stationIDs = Object.keys(stationData);
var whereClause = "stationid IN ('" + stationIDs.join("','") + "')";

function getColor(pct){ return pct >= 95 ? "#e31a1c" : pct >= 80 ? "#fdae6b" : pct >= 50 ? "#74c476" : "#c7e9c0"; }

var gaugeContainer = document.getElementById("gaugeContainer");
var gaugeListData = [];
var gauges;

function loadGauges() {
  document.getElementById('gaugesError').style.display = 'none';
  gaugeContainer.innerHTML = '<div class="loading">Loading gauges...</div>';
  
  if (gauges) {
    map.removeLayer(gauges);
  }
  
  gaugeListData = [];
  
  gauges = L.esri.featureLayer({
    url: "https://services9.arcgis.com/RHVPKKiFTONKtxq3/arcgis/rest/services/Live_Stream_Gauges_v1/FeatureServer/0",
    where: whereClause,
    pointToLayer: function(feature, latlng){
      var sm = feature.properties.stage_ft * 0.3048;
      var normal = stationData[feature.properties.stationid].TopNormal;
      var pct = sm / normal * 100;
      return L.circleMarker(latlng, { 
        radius: 8 + sm*2, 
        fillColor: getColor(pct), 
        color: "#111", 
        weight:1, 
        fillOpacity:0.9 
      });
    },
    onEachFeature: function(feature, layer){
      var p = feature.properties;
      var sm = p.stage_ft * 0.3048;
      var sdata = stationData[p.stationid];
      var normal = sdata.TopNormal;
      var pct = sm / normal * 100;
      var pct_txt = pct.toFixed(1);
      var updated = p.lastupdate ? new Date(p.lastupdate).toLocaleString() : "N/A";

      layer.bindPopup(`
        <strong>${p.name}</strong><br><br>
        <b>Current Level:</b> ${sm.toFixed(2)} m<br>
        <b>Top of Normal Range:</b> ${normal.toFixed(2)} m<br>
        <b>Percent of Normal:</b> ${pct_txt}%<br><br>
        <b>Possible Property Flooding:</b> ${sdata.PossibleFlood !== null ? sdata.PossibleFlood.toFixed(2)+" m" : "N/A"}<br>
        <b>Max Height Recorded:</b> ${sdata.Max.toFixed(2)} m<br><br>
        <b>Last updated:</b> ${updated}
      `);
      
      // Bring to front on click to ensure accessibility
      layer.on('click', function() {
        this.bringToFront();
      });

      gaugeListData.push({ name: p.name, level: sm.toFixed(2), normal: normal.toFixed(2), pct: pct, pct_txt: pct_txt, color: getColor(pct), possibleFlood: sdata.PossibleFlood, max: sdata.Max });
    }
  });

  gauges.on("load", function(){
    gaugeContainer.innerHTML = "";
    gaugeListData.sort((a,b)=>b.pct-a.pct);
    gaugeListData.forEach(g=>{
      var item = document.createElement("div");
      item.className="gauge-item";
      item.innerHTML = `<span class="gauge-dot" style="background:${g.color}"></span><strong>${g.name}</strong><br>${g.level} m / ${g.normal} m<br><small>${g.pct_txt}% of Top of Normal Range</small><div class="sparkline"><div class="sparkline-bar" style="width:${Math.min(g.pct,130)}%; background:${g.color}"></div></div>`;
      gaugeContainer.appendChild(item);
    });
    document.getElementById('gaugesUpdated').textContent = 'Last updated: ' + new Date().toLocaleTimeString();
  });
  
  gauges.on("error", function(err){
    console.error('Gauge loading error:', err);
    document.getElementById('gaugesError').textContent = 'Failed to load river gauges. Please try refreshing.';
    document.getElementById('gaugesError').style.display = 'block';
    gaugeContainer.innerHTML = '<div style="text-align:center;color:#999;">Unable to load gauges</div>';
  });

  gauges.addTo(map);
}

function refreshGauges() {
  const btn = event.target;
  btn.classList.add('spinning');
  loadGauges();
  setTimeout(() => btn.classList.remove('spinning'), 1000);
}

loadGauges();

/* ---- Load Shorncote Rainfall ---- */
const STATION = '248332TP';
const BASE = 'https://environment.data.gov.uk/flood-monitoring';
const readingsUrl = `${BASE}/id/stations/${STATION}/readings?_sorted&_limit=200`;

function parseTimestamp(item) { return item.dateTime || item.datetime || item.date || item.timestamp || null; }
function parseValue(item) { return parseFloat(item.value || item.reading || item.measurement || item.rainfall) || 0; }

let rainfallChart;

async function loadRainfall() {
  document.getElementById('rainfallError').style.display = 'none';
  document.getElementById('rainfallUpdated').textContent = 'Loading...';
  
  try {
    const rResp = await fetch(readingsUrl);
    if (!rResp.ok) throw new Error('Failed to fetch rainfall data');
    
    const rJson = await rResp.json();
    const items = Array.isArray(rJson.items) ? rJson.items : [];
    const normalized = items.map(it => ({ ts: parseTimestamp(it), v: parseValue(it) })).filter(x => x.ts && x.v !== null);
    normalized.sort((a,b) => new Date(a.ts)-new Date(b.ts));

    const now = new Date();
    const sumInRange = ms => normalized.reduce((acc, cur) => (new Date(cur.ts) >= new Date(now.getTime()-ms) ? acc+cur.v : acc), 0);

    document.getElementById('t1').textContent = sumInRange(1*60*60*1000).toFixed(2)+' mm';
    document.getElementById('t6').textContent = sumInRange(6*60*60*1000).toFixed(2)+' mm';
    document.getElementById('t24').textContent = sumInRange(24*60*60*1000).toFixed(2)+' mm';

    const ctx = document.getElementById('barChart').getContext('2d');
    const displayCount = 48;
    const last = normalized.slice(-displayCount);
    
    if (rainfallChart) {
      rainfallChart.destroy();
    }
    
    rainfallChart = new Chart(ctx, {
      type: 'bar',
      data: { labels: last.map(i => new Date(i.ts).toLocaleString()), datasets:[{ label:'Rainfall (mm)', data:last.map(i=>i.v) }] },
      options: { responsive:true, maintainAspectRatio:false, scales:{ x:{display:true}, y:{beginAtZero:true} } }
    });
    
    document.getElementById('rainfallUpdated').textContent = 'Last updated: ' + new Date().toLocaleTimeString();
  } catch(err){ 
    console.error(err);
    document.getElementById('rainfallError').textContent = 'Failed to load rainfall data. Please try refreshing.';
    document.getElementById('rainfallError').style.display = 'block';
    document.getElementById('rainfallUpdated').textContent = '';
  }
}

function refreshRainfall() {
  const btn = event.target;
  btn.classList.add('spinning');
  loadRainfall().finally(() => {
    setTimeout(() => btn.classList.remove('spinning'), 1000);
  });
}

loadRainfall();

/* ---- Load Wiltshire Flood Alerts ---- */
const alertLayer = L.layerGroup().addTo(map);
const county = 'Wiltshire';
const floodsURL = `${BASE}/id/floods?county=${encodeURIComponent(county)}`;

function colorForSeverity(sev) {
  const s = (sev || '').toLowerCase();
  if (s.includes('severe') || s.includes('warning')) return '#d73027';
  if (s.includes('alert') || s.includes('advisory')) return '#fc8d59';
  return '#fee08b';
}

async function loadFloods() {
  document.getElementById('floodsError').style.display = 'none';
  document.getElementById('floodCount').textContent = 'Loading...';
  document.getElementById('floodsUpdated').textContent = '';
  
  alertLayer.clearLayers();
  
  try {
    const res = await fetch(floodsURL);
    if (!res.ok) throw new Error('Failed to fetch flood data');
    
    const data = await res.json();
    const items = data.items || [];
    
    const floodCountEl = document.getElementById('floodCount');
    if (!items.length) {
      floodCountEl.textContent = '0 active alerts';
      document.getElementById('floodsUpdated').textContent = 'Last updated: ' + new Date().toLocaleTimeString();
      return;
    }
    
    floodCountEl.textContent = `${items.length} active alert${items.length !== 1 ? 's' : ''}`;

    for (const f of items) {
      const fa = f.floodArea;
      if (!fa || !fa.polygon) continue;

      let polyUrl = fa.polygon.endsWith('.geojson')
	  ? fa.polygon
	  : fa.polygon + '.geojson';

	// Ensure HTTPS
	polyUrl = polyUrl.replace(/^http:\/\//i, 'https://');


      try {
        const a = await fetch(polyUrl);
        if (!a.ok) continue;
        const gj = await a.json();

        const fillColor = colorForSeverity(f.severity || f.type || '');

        const layer = L.geoJSON(gj, {
          style: {
            color: '#000',
            weight: 2,
            fillColor: fillColor,
            fillOpacity: 0.5
          }
        }).addTo(alertLayer);

        const popupHtml = `
          <div class="overlay-popup">
            <strong>${f.label || fa.notation || 'Flood Area'}</strong><br>
            <b>Severity:</b> ${f.severity || ''}<br>
            <b>Description:</b> ${f.description || ''}<br>
            ${f.message ? `<b>Message:</b> ${f.message}<br>` : ''}
            <b>Area code:</b> ${fa.notation || ''}<br>
            <a href="${f['@id'] || '#'}" target="_blank">Full alert</a>
          </div>
        `;
        layer.bindPopup(popupHtml);

      } catch (err) {
        console.error('Error loading polygon for', fa.notation, err);
      }
    }
    
    document.getElementById('floodsUpdated').textContent = 'Last updated: ' + new Date().toLocaleTimeString();

  } catch (err) {
    console.error('Failed to load flood alerts:', err);
    document.getElementById('floodsError').textContent = 'Failed to load flood alerts. Please try refreshing.';
    document.getElementById('floodsError').style.display = 'block';
    document.getElementById('floodCount').textContent = 'Error loading';
  }
}

function refreshFloods() {
  const btn = event.target;
  btn.classList.add('spinning');
  loadFloods().finally(() => {
    setTimeout(() => btn.classList.remove('spinning'), 1000);
  });
}

loadFloods();

/* ---- Toggle Flood Layer ---- */
let floodLayerVisible = true;
function toggleFloodLayer() {
  const btn = document.getElementById('toggleFloodBtn');
  if (floodLayerVisible) {
    map.removeLayer(alertLayer);
    btn.textContent = 'Show Flood Alerts';
    btn.className = 'toggle-btn off';
  } else {
    map.addLayer(alertLayer);
    btn.textContent = 'Hide Flood Alerts';
    btn.className = 'toggle-btn';
  }
  floodLayerVisible = !floodLayerVisible;
}
</script>

</body>
</html>